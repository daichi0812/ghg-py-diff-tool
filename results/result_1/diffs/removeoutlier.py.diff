--- /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/analysis/removeoutlier.py
+++ /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/simulator/nagasu/removeoutlier.py
@@ -1,15 +1,10 @@
 #http://www.not-enough.org/abe/manual/program-aa08/pyqt1.html

-

-from OpenGL.GL import *

-from OpenGL.GLU import *

-from OpenGL.GLUT import *

-from PyQt5 import QtCore, QtGui, QtWidgets

-from PyQt5.QtOpenGL import *

 import math

 import copy

 from grainh5 import *

 from forceh5 import *

 from homogenizationh5 import *

+import ctypes

 

 class RemoveOutlier:

     def __init__(self):

@@ -31,16 +26,16 @@
     def calcPackingfraction(self, scene_data):

         #set packing fraction data

         N = np.prod(self.resolution)

-        packing_fraction = np.zeros(N,dtype=ctypes.c_float)

-        for e in scene_data.elements:

-            if e.static==True:

+        packing_fraction = np.zeros(N, dtype=ctypes.c_float)

+        for i in range(len(scene_data.all_step_elements_center_of_mass_array)):

+            if scene_data.all_step_elements_static_array[i]:

                 continue

-            cell_idx = np.floor((e.center_of_mass - self.grid_start) / self.h).astype(int)

+            cell_idx = np.floor((scene_data.all_step_elements_center_of_mass_array[i] - self.grid_start) / self.h).astype(int)

             flat_idx = cell_idx[1] * self.resolution[0] + cell_idx[0]

             if flat_idx >= N or flat_idx < 0:   #剛体の中心が格子の外にある

                 continue

-            e_template = scene_data.templates[e.template_name]

-            packing_fraction[flat_idx] += e.size_ratio * e.size_ratio * self.computeArea(e_template.vertex_list, e_template.size_mean)

+            e_template = scene_data.templates[scene_data.all_step_elements_template_idx_to_name_dict[scene_data.all_step_elements_template_idx_array[i]]]

+            packing_fraction[flat_idx] += scene_data.all_step_elements_size_ratio_array[i] * scene_data.all_step_elements_size_ratio_array[i] * self.computeArea(e_template.vertex_list, e_template.size_mean)

 

         cell_volume = self.h * self.h

         for j in range(self.resolution[1]):

@@ -51,7 +46,7 @@
 

     def calcdistancefromwall(self, left_wall_position, floor_wall_position):

         N = np.prod(self.resolution)

-        distance_from_wall = np.zeros(N,dtype=ctypes.c_float)

+        distance_from_wall = np.zeros(N, dtype=ctypes.c_float)

         for j in range(self.resolution[1]):

             for i in range(self.resolution[0]):

                 grid_center_p = self.grid_start + self.h * np.array([i+0.5, j+0.5])

@@ -68,30 +63,29 @@
         self.resolution = homogenization_data.homogenization[0].resolution

         self.h = homogenization_data.homogenization[0].h

         N = np.prod(self.resolution)

-        self.packing_fraction = np.zeros(N,dtype=ctypes.c_float)

-        self.distance_from_wall = np.zeros(N,dtype=ctypes.c_float)

-        left_wall_position=[2]

-        floor_wall_position=[2]

+        self.packing_fraction = np.zeros(N, dtype=ctypes.c_float)

+        self.distance_from_wall = np.zeros(N, dtype=ctypes.c_float)

+        left_wall_position = np.array([0.0, 0.0]).transpose()

+        floor_wall_position = np.array([0.0, 0.0]).transpose()

         left_wall_position[0] = None

         floor_wall_position[0] = None

+        #壁の中心座標を取り出す

 

-        #壁の中心座標を取り出す

-        for e in data.elements:

-            if e.template_name == "left_wall":

-                if  left_wall_position[0] == None:

-                        left_wall_position=e.center_of_mass

-                else:   print("WARNING:exist two left wall. rewrite this code.")

-            if e.template_name == "floor_circle":

-                if floor_wall_position[0] ==None or floor_wall_position.all() ==e.center_of_mass.all():

-                    floor_wall_position = e.center_of_mass

-                else: print("フロアの中心がずれています")

+        for i in range(len(data.all_step_elements_center_of_mass_array)):

+            if data.all_step_elements_template_idx_to_name_dict[data.all_step_elements_template_idx_array[i]] == "left_wall":

+                left_wall_position[0] = math.fabs(data.templates[data.all_step_elements_template_idx_to_name_dict[data.all_step_elements_template_idx_array[i]]].vertex_list[0][1] + data.templates[data.all_step_elements_template_idx_to_name_dict[data.all_step_elements_template_idx_array[i]]].vertex_list[0][0])

+                

+            if data.all_step_elements_template_idx_to_name_dict[data.all_step_elements_template_idx_array[i]] == "floor_circle":

+                if floor_wall_position[0] == None or floor_wall_position.all() == data.all_step_elements_center_of_mass_array[i].all():

+                    floor_wall_position = data.all_step_elements_center_of_mass_array[i]

+                else:print("フロアの中心がずれています")

 

         #パッキング率を計算

         self.packing_fraction = self.calcPackingfraction(data)

         #グリッド中心から壁からの最短距離を求める

         self.distance_from_wall = self.calcdistancefromwall(left_wall_position, floor_wall_position)

 

-    

+

     def removeGrid(self, homogenization_data, packing_fraction_threshold, distance_from_wall_threshold):

         self.resolution = homogenization_data.homogenization[0].resolution

         for j in range(self.resolution[1]):
