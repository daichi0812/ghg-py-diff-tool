key,exists_p1,path_p1,collision_p1,exists_p2,path_p2,collision_p2,same,status,diff_file,diff_text
allforceh5.py,True,allforceh5.py,,True,allforceh5.py,,False,diff,../output/diffs/allforceh5.py.diff,"--- /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/analysis/allforceh5.py
+++ /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/simulator/nagasu/allforceh5.py
@@ -1,10 +1,16 @@
 import h5py

 import numpy as np

+import os

+import ctypes

 from forceh5 import *

 

 class AllForceData:

     def __init__(self):

-        self.all_step_ForceData = []

+        self.estimate_force_num = 200000

+        self.force_num = 0

+        self.all_step_ForceData_position = np.zeros((self.estimate_force_num, 2), dtype=ctypes.c_float)

+        self.all_step_ForceData_arm = np.zeros((self.estimate_force_num, 2), dtype=ctypes.c_float)

+        self.all_step_ForceData_force = np.zeros((self.estimate_force_num, 2), dtype=ctypes.c_float)

 

     def __load_forces(self, fileName):

         if fileName != """" and fileName[len(fileName)-3:] == "".h5"":

@@ -40,7 +46,7 @@
         if fileName != """" and fileName[len(fileName) - 3:] == "".h5"":

             self.all_step_ForceData.clear()

             with h5py.File(fileName, 'r') as h5_forces:

-                #idx番目のkeyを取得

+                # idx番目のkeyを取得

                 keys = list(map(str, h5_forces.keys()))

                 keys.remove('force_num')

                 keys = list(map(int, keys))

@@ -61,8 +67,39 @@
                     f.force = force_array[:, i]

                     force.forces.append(f)

                 self.all_step_ForceData.append(force)

+

     def load_from_idx(self, fn_element, idx):

         self.__load_forces_from_idx(fn_element, idx)

+

+    def __load_forces_from_idx_for_simulation(self, fileName, idx):

+        #print(""debug - allforceh5.py : __load_forces_from_idx_for_simulation (fileName) = "", fileName)

+        ext_without_dot = os.path.splitext(fileName)[1][1:]

+        if ext_without_dot == ""h5"":

+            # print(""debug - allforceh5.py : __load_forces_from_idx_for_simulation (fileName) = "", fileName)

+            self.all_step_ForceData_position = np.zeros((self.estimate_force_num, 2), dtype=ctypes.c_float)

+            self.all_step_ForceData_arm = np.zeros((self.estimate_force_num, 2), dtype=ctypes.c_float)

+            self.all_step_ForceData_force = np.zeros((self.estimate_force_num, 2), dtype=ctypes.c_float)

+            with h5py.File(fileName, 'r') as h5_forces:

+                #idx番目のkeyを取得

+                keys = list(map(str, h5_forces.keys()))

+                keys.remove('force_num')

+                keys = list(map(int, keys))

+                newlist = sorted(keys)

+

+                data_group = h5_forces[str(newlist[idx])]

+                f_group = data_group['forces_2d']

+                # print(""debug - allforceh5.py f_group = "", f_group)

+                self.all_step_ForceData_position = np.array(f_group['position'], dtype=np.float64).transpose()

+                # print(""debug - allforceh5.py (self.all_step_ForceData_position) = "", self.all_step_ForceData_position)

+                self.all_step_ForceData_arm = np.array(f_group['arm'], dtype=np.float64).transpose()

+                self.all_step_ForceData_force = np.array(f_group['force'], dtype=np.float64).transpose()

+                self.force_num = np.array(f_group['position'], dtype=np.float64).transpose().shape[0]

+

+    def load_from_idx(self, fn_element, idx):

+        self.__load_forces_from_idx(fn_element, idx)

+

+    def load_from_idx_for_simulation(self, fn_element, idx):

+        self.__load_forces_from_idx_for_simulation(fn_element, idx)

 

 def force_data_num(post_fn):

     with h5py.File(post_fn, 'r') as h5_forces:
"
allgrainh5.py,True,allgrainh5.py,,True,allgrainh5.py,,False,diff,../output/diffs/allgrainh5.py.diff,"--- /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/analysis/allgrainh5.py
+++ /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/simulator/nagasu/allgrainh5.py
@@ -1,12 +1,21 @@
 import h5py

 import numpy as np

 from grainh5 import *

-

+import ctypes

 

 class AllSceneData:

     def __init__(self):

         self.templates = {}

         self.all_step_elements = []

+        self.all_step_elements_template_idx_array = np.zeros(1, dtype=ctypes.c_int)

+        self.all_step_elements_size_ratio_array = np.zeros(1, dtype=ctypes.c_float)

+        self.all_step_elements_center_of_mass_array = np.zeros((1, 2), dtype=ctypes.c_float)

+        self.all_step_elements_rotation_angle_array = np.zeros(1, dtype=ctypes.c_float)

+        self.all_step_elements_velocity_array = np.zeros((1, 2), dtype=ctypes.c_float)

+        self.all_step_elements_angular_velocity_array = np.zeros(1, dtype=ctypes.c_float)

+        self.all_step_elements_static_array = np.zeros(1, dtype=ctypes.c_int)

+        self.all_step_elements_template_idx_to_name_dict = {}

+

 

     def __load_templates(self, fileName):

         if fileName != """" and fileName[len(fileName)-3:] == "".h5"":

@@ -124,6 +133,94 @@
         self.__load_templates(fn_template)

         self.__load_elements_from_idx(fn_element, idx)

 

+    def __load_elements(self, fileName):

+        if fileName != """" and fileName[len(fileName) - 3:] == "".h5"":

+

+            template_idx_to_name_dict = {}

+            with h5py.File(fileName, 'r') as h5_elements:

+                keys = list(map(str, h5_elements.keys()))

+                keys.remove('force_num')

+                keys = list(map(int, keys))

+                newlist = sorted(keys)

+                for t in newlist:

+                    data_group = h5_elements[str(t)]

+                    e_group = data_group['elements_2d']

+                    tn_group = data_group['template_name_dict']

+                    template_idxs = list(tn_group.keys())

+

+                    for i in template_idxs:

+                        template_idx_to_name_dict.update([(int(i), tn_group[i][0].decode())])

+

+                    template_idx_array = np.array(e_group['template_idx'], dtype=np.int32)

+                    size_ratio_array = np.array(e_group['size_ratio'], dtype=np.float64)

+                    center_of_mass_array = np.array(e_group['center_of_mass'], dtype=np.float64)

+                    rotation_angle_array = np.array(e_group['rotation_angle'], dtype=np.float64)

+                    velocity_array = np.array(e_group['velocity'], dtype=np.float64)

+                    angular_velocity_array = np.array(e_group['angular_velocity'], dtype=np.float64)

+                    static_array = np.array(e_group['static'], dtype=np.int8)

+                    # static_array = np.array(e_group['static'], dtype=np.bool)

+

+                    num_elems = len(size_ratio_array)

+

+                    scene_data = SceneData()

+                    for i in range(num_elems):

+                        e = Element()

+                        e.template_name = template_idx_to_name_dict[template_idx_array[i]]

+                        e.size_ratio = size_ratio_array[i]

+                        e.center_of_mass = center_of_mass_array[:, i]

+                        e.rotation_angle = rotation_angle_array[i]

+                        e.velocity = velocity_array[:, i]

+                        # e.angular_velocity = angular_velocity_array[i]

+                        e.static = False if static_array[i] == 0 else True

+                        e.static = static_array[i]

+                        scene_data.elements.append(e)

+                    scene_data.templates = self.templates

+                    self.all_step_elements.append(scene_data)

+

+    def load(self, fn_template, fn_element):

+        self.__load_templates(fn_template)

+        self.__load_elements(fn_element)

+

+    def __load_elements_from_idx_for_simulation(self, fileName, idx):

+        self.all_step_elements_template_idx_array = np.zeros(1, dtype=ctypes.c_int)

+        self.all_step_elements_size_ratio_array = np.zeros(1, dtype=ctypes.c_float)

+        self.all_step_elements_center_of_mass_array = np.zeros((1, 2), dtype=ctypes.c_float)

+        self.all_step_elements_rotation_angle_array = np.zeros(1, dtype=ctypes.c_float)

+        self.all_step_elements_velocity_array = np.zeros((1, 2), dtype=ctypes.c_float)

+        self.all_step_elements_angular_velocity_array = np.zeros(1, dtype=ctypes.c_float)

+        self.all_step_elements_static_array = np.zeros(1, dtype=ctypes.c_int)

+

+        if fileName != """" and fileName[len(fileName) - 3:] == "".h5"":

+

+            self.all_step_elements_template_idx_to_name_dict = {}

+            with h5py.File(fileName, 'r') as h5_elements:

+                # idx番目のkeyを取得する

+                keys = list(map(str, h5_elements.keys()))

+                if 'force_num' in keys:

+                    keys.remove('force_num')

+                keys = list(map(int, keys))

+                newlist = sorted(keys)

+

+                data_group = h5_elements[str(newlist[idx])]

+                e_group = data_group['elements_2d']

+                tn_group = data_group['template_name_dict']

+                template_idxs = list(tn_group.keys())

+

+                for i in template_idxs:

+                    self.all_step_elements_template_idx_to_name_dict.update([(int(i), tn_group[i][0].decode())])

+

+                self.all_step_elements_template_idx_array = np.array(e_group['template_idx'], dtype=np.int32)

+                self.all_step_elements_size_ratio_array = np.array(e_group['size_ratio'], dtype=np.float64)

+                self.all_step_elements_center_of_mass_array = np.array(e_group['center_of_mass'], dtype=np.float64).transpose()

+                self.all_step_elements_rotation_angle_array = np.array(e_group['rotation_angle'], dtype=np.float64)

+                self.all_step_elements_velocity_array = np.array(e_group['velocity'], dtype=np.float64).transpose()

+                self.all_step_elements_angular_velocity_array = np.array(e_group['angular_velocity'], dtype=np.float64).transpose()

+                self.all_step_elements_static_array = np.array(e_group['static'], dtype=np.int8)

+

+    def load_from_idx_for_simulation(self, fn_template, fn_element, idx):

+        self.__load_templates(fn_template)

+        self.__load_elements_from_idx_for_simulation(fn_element, idx)

+

     @staticmethod

     def get_key_list(filename):

         if filename == """" or filename[len(filename) - 3:] != "".h5"":
"
allhomogenizationh5.py,True,allhomogenizationh5.py,,True,allhomogenizationh5.py,,False,diff,../output/diffs/allhomogenizationh5.py.diff,
allstepHomogenizer.py,True,allstepHomogenizer.py,,True,allstepHomogenizer.py,,False,diff,../output/diffs/allstepHomogenizer.py.diff,"--- /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/analysis/allstepHomogenizer.py
+++ /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/simulator/nagasu/allstepHomogenizer.py
@@ -5,16 +5,24 @@
 from allhomogenizationh5 import *

 from removeoutlier import *

 import os

-import xml.etree.ElementTree as ET 

+import xml.etree.ElementTree as ET

 import sys

+import time

 

 #全ステップの力をロードする。allforce[step]=forceData()

 args = sys.argv

+

 if len(args) < 2:

     print('rewriteResumefn.py homogenize_stress_fn')

 resume_xml_fn = args[1]

 tree = ET.parse(resume_xml_fn)

 root = tree.getroot()

+

+#処理時間を開始

+if root[6].attrib[""mode""] == ""11"":

+    processing_time_fn = root[6].attrib[""processing_time""]

+    start_time = time.perf_counter_ns()

+

 if root[0].tag !=""elements"":

     print(""not elements line"")

 template_fn = root[0].attrib[""templates""]

@@ -87,3 +95,9 @@
 

 allhomogenization_data.save(filename)

 strain_data.save(strain_fn)

+

+#処理時間計測を終了

+if root[6].attrib[""mode""] == ""11"":

+    end_time = time.perf_counter_ns()

+    with open(processing_time_fn, 'a') as f:

+        print((end_time - start_time) / 1000000.0, file=f)
"
allstepMPMBeforeflow.py,True,allstepMPMBeforeflow.py,,True,allstepMPMBeforeflow.py,,False,diff,../output/diffs/allstepMPMBeforeflow.py.diff,"--- /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/analysis/allstepMPMBeforeflow.py
+++ /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/simulator/nagasu/allstepMPMBeforeflow.py
@@ -6,16 +6,15 @@
 import xml.etree.ElementTree as ET 

 import sys

 import subprocess

+import time

+import ctypes

 

 #全ステップの力をロード

 args = sys.argv

-if len(args) < 2:

-    print('rewriteResumefn.py homogenize_stress_fn')

 resume_xml_fn = args[1]

 tree = ET.parse(resume_xml_fn)

 root = tree.getroot()

-if root[0].tag !=""elements"":

-    print(""not resume line"")

+

 element_fn = root[0].attrib[""MPMstress""]

 allelements = AllParticleHomogenizeData()

 #全ステップ粒子ロードする

@@ -24,8 +23,6 @@
 

 allhomogenization_data = AllHomogenizeData()

 

-if root[1].tag !=""stress"":

-    print(""not stress line"")

 pre_fn = root[1].attrib[""pre_stress""]

 #２週目以降はファイルをロードする

 """"""

@@ -35,29 +32,24 @@
 """"""

 

 #grid_startを取ってくる

-if root[1].tag !=""stress"":

-    print(""not resume line"")

 post_fn = root[1].attrib[""post_stress""]

 allpost_homogenization_data = AllHomogenizeData()

 allpost_homogenization_data.load(post_fn)

 

 #gridのパラメータ

-if root[4].tag !=""grid"":

-    print(""not grid line"")

 h = float(root[4].attrib[""h""])

 

 #density

 # XMLファイルを解析

-if root[2].tag !=""resume"":

-    print(""not resume line"")

 resume_fn = root[2].attrib[""resume_MPM_fn""]

 resume_tree = ET.parse(resume_fn)

 resume_root = resume_tree.getroot()

-if resume_root[2].tag !=""particles"":

-    print(""not particles line"")

 density = float(resume_root[2].attrib[""density""])

 

 #タイムステップ取得

+#print(os.path.getsize(element_fn))

+#print(os.path.exists(element_fn))

+

 with h5py.File(element_fn, ""r"") as h5:

     keys = list(map(int, h5.keys()))

     sorted_keys = sorted(keys)

@@ -79,7 +71,7 @@
     interpolate_stress.interpolateStress()

     interpolate_stress.saveStress(homogenization_data)

     allhomogenization_data.all_step_homogenization.append(homogenization_data)

-    print(i)

+

 allhomogenization_data.save(pre_fn)

 

     "
allsteptiHomogenizerSleep.py,False,,,True,allsteptiHomogenizerSleep.py,,,only_p2,,
allstressplot.py,True,allstressplot.py,,True,allstressplot.py,,True,same,,
allstressviewer.py,True,allstressviewer.py,,True,allstressviewer.py,,True,same,,
compareDEMStress.py,True,compareDEMStress.py,,True,compareDEMStress.py,,True,same,,
compareForceAndGravity.py,True,compareForceAndGravity.py,,True,compareForceAndGravity.py,,True,same,,
compareGrainsFile.py,False,,,True,compareGrainsFile.py,,,only_p2,,
compareHomogenizeStress.py,True,compareHomogenizeStress.py,,True,compareHomogenizeStress.py,,True,same,,
compareStressPairs.py,False,,,True,compareStressPairs.py,,,only_p2,,
deleteIntermediateFile.py,False,,,True,deleteIntermediateFile.py,,,only_p2,,
extractStressPlot.py,True,extractStressPlot.py,,True,extractStressPlot.py,,False,diff,../output/diffs/extractStressPlot.py.diff,"--- /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/analysis/extractStressPlot.py
+++ /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/simulator/nagasu/extractStressPlot.py
@@ -28,11 +28,20 @@
         self.camera_y_pos_label = QtWidgets.QLabel(""cp: "")

         self.camera_y_pos_slider = self.create_slider(QtCore.Qt.Vertical, 0, 100, 50, self.update_camera_pos)

 

+        self.plot_y_move_label = QtWidgets.QLabel(""axis y: "")

+        self.plot_y_move_slider = self.create_slider(QtCore.Qt.Vertical, -10000, 5000, 0, self.update_axis_y)

+

         self.camera_x_pos_label = QtWidgets.QLabel(""camera pos: "")

         self.camera_x_pos_slider = self.create_slider(QtCore.Qt.Horizontal, 0, 100, 50, self.update_camera_pos)

 

+        self.plot_x_move_label = QtWidgets.QLabel(""axis x: "")

+        self.plot_x_move_slider = self.create_slider(QtCore.Qt.Horizontal, -10000, 5000, 0, self.update_axis_x)

+

         self.camera_zoom_label = QtWidgets.QLabel(""camera zoom: "")

         self.camera_zoom_slider = self.create_slider(QtCore.Qt.Horizontal, 0, 100, 50, self.update_camera_pos)

+

+        self.plot_zoom_label = QtWidgets.QLabel(""plot zoom: "")

+        self.plot_zoom_slider = self.create_slider(QtCore.Qt.Horizontal, 0, 100, 50, self.update_plot_zoom)

 

         self.dt_plot_label = QtWidgets.QLabel(""t: "")

         self.dt_plot_slider = self.create_slider(QtCore.Qt.Horizontal, 0, 1000, 0, self.update_dt)

@@ -71,10 +80,18 @@
         camera_y_pos_box.addWidget(self.camera_y_pos_label, alignment=QtCore.Qt.Alignment())

         camera_y_pos_box.addWidget(self.camera_y_pos_slider, alignment=QtCore.Qt.Alignment())

 

+        plot_move_y_pos_box = QtWidgets.QVBoxLayout()

+        plot_move_y_pos_box.addWidget(self.plot_y_move_label, alignment=QtCore.Qt.Alignment())

+        plot_move_y_pos_box.addWidget(self.plot_y_move_slider, alignment=QtCore.Qt.Alignment())

+

         dt_plot_box = QtWidgets.QHBoxLayout()

         dt_plot_box.addWidget(self.dt_plot_label, alignment=QtCore.Qt.Alignment())

         dt_plot_box.addWidget(self.dt_plot_slider, alignment=QtCore.Qt.Alignment())

 

+        plot_move_x_pos_box = QtWidgets.QHBoxLayout()

+        plot_move_x_pos_box.addWidget(self.plot_x_move_label, alignment=QtCore.Qt.Alignment())

+        plot_move_x_pos_box.addWidget(self.plot_x_move_slider, alignment=QtCore.Qt.Alignment())

+

         plot_box = QtWidgets.QVBoxLayout()

         plot_box.addWidget(self.stress_plot_canvas, alignment=QtCore.Qt.Alignment())

         plot_box.addLayout(dt_plot_box)

@@ -89,20 +106,24 @@
 

         upper_box = QtWidgets.QHBoxLayout()

         upper_box.addLayout(plot_box)

+        upper_box.addLayout(plot_move_y_pos_box)

         upper_box.addLayout(gl_box)

         upper_box.addLayout(camera_y_pos_box)

 

         label_box = QtWidgets.QVBoxLayout()

         label_box.addWidget(self.camera_x_pos_label, alignment=QtCore.Qt.Alignment())

         label_box.addWidget(self.camera_zoom_label, alignment=QtCore.Qt.Alignment())

+        label_box.addWidget(self.plot_zoom_label, alignment=QtCore.Qt.Alignment())

 

         slider_box = QtWidgets.QVBoxLayout()

         slider_box.addWidget(self.camera_x_pos_slider, alignment=QtCore.Qt.Alignment())

         slider_box.addWidget(self.camera_zoom_slider, alignment=QtCore.Qt.Alignment())

+        slider_box.addWidget(self.plot_zoom_slider, alignment=QtCore.Qt.Alignment())

 

         slider_label_box = QtWidgets.QHBoxLayout()

         slider_label_box.addLayout(label_box)

         slider_label_box.addLayout(slider_box)

+        slider_label_box.addLayout(plot_move_x_pos_box)

 

         checkboxes = QtWidgets.QHBoxLayout()

         checkboxes.addWidget(self.grains_checkbox, alignment=QtCore.Qt.Alignment())

@@ -236,6 +257,11 @@
         zoom_level = math.pow(2.0, (self.camera_zoom_slider.value() - 50.0) * side_mag_level / 50.0)

         self.gl.set_view_info(x_pos, y_pos, zoom_level)

 

+    def update_plot_zoom(self):

+        side_mag_level = 5  # 2^5 = 32x magnification

+        zoom_level = math.pow(2.0, (self.plot_zoom_slider.value() - 50.0) * side_mag_level / 50.0)

+        self.stress_plot_canvas.set_zoom_plot(zoom_level)

+

     def check_box_changed(self):

         self.gl.toggle_draw(self.grains_checkbox.isChecked(), self.selected_cell_checkbox.isChecked(),

                             self.grid_checkbox.isChecked())

@@ -269,13 +295,13 @@
         # self.scene_fn = ""Save/serialized_forces.h5""

 

         # プロット用応力データ

-        stress_fn = ""simulated_data/11/compressed_stress.h5""

+        stress_fn = ""Save_circle12_flow/compressed_stress.h5""

 

         # 描画用粒子データ

-        self.scene_fn = ""simulated_data/11/element_data_0.500000.h5""

+        self.scene_fn = ""Rolling_circle12_flow/element_data.h5""

 

         # テンプレートファイル

-        self.template_fn = ""simulated_data/11/square_merge_template.h5""

+        self.template_fn = ""Save_circle12_flow/circle12_flow_template.h5""

 

         self.all_stress_pair_data.load(stress_fn)

         self.stress_plot_canvas.set_all_stress_pair_data(self.all_stress_pair_data)

@@ -284,6 +310,15 @@
         self.init_dt_slider()

         self.set_plot_mode_label()

 

+    def update_axis_x(self):

+        self.x_move = float(self.plot_x_move_slider.value())

+        self.stress_plot_canvas.set_move_plot_range_x(self.x_move)

+

+    def update_axis_y(self):

+        self.y_move = float(self.plot_y_move_slider.value())

+        self.stress_plot_canvas.set_move_plot_range_y(self.y_move)

+

+

     def plot_per_timestep(self):

         self.stress_plot_canvas.plot_data_per_timestep()

         self.set_plot_mode_label()
"
forceCalculatorMPM.py,True,forceCalculatorMPM.py,,True,forceCalculatorMPM.py,,True,same,,
forceh5.py,True,forceh5.py,,True,forceh5.py,,True,same,,
geninitialcolumn.py,False,,,True,geninitialcolumn.py,,,only_p2,,
grainRender.py,False,,,True,grainRender.py,,,only_p2,,
grainViewer.py,False,,,True,grainViewer.py,,,only_p2,,
grainh5.py,True,grainh5.py,,True,grainh5.py,,True,same,,
homogenizationh5.py,True,homogenizationh5.py,,True,homogenizationh5.py,,True,same,,
homogenizer.py,True,homogenizer.py,,True,homogenizer.py,,True,same,,
homogenizerti.py,False,,,True,homogenizerti.py,,,only_p2,,
initPiledSim.py,False,,,True,initPiledSim.py,,,only_p2,,
initResumefn.py,True,initResumefn.py,,True,initResumefn.py,,False,diff,../output/diffs/initResumefn.py.diff,"--- /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/analysis/initResumefn.py
+++ /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/simulator/nagasu/initResumefn.py
@@ -1,6 +1,8 @@
 import xml.etree.ElementTree as ET 

 import sys

 from progressh5 import *

+import pathlib

+import os

 

 

 def main():

@@ -60,6 +62,26 @@
     resume_tree.write(resume_xml_fn)

     tree.write(homogenize_stress_fn)

 

+    #処理時間計測のためのファイル作成

+    resume_MPM_xml_fn = root[2].attrib[""resume_MPM_fn""]

+    resume_MPM_tree = ET.parse(resume_MPM_xml_fn)

+    resume_MPM_root = resume_MPM_tree.getroot()

+    if os.path.isfile(root[6].attrib[""processing_time""]):

+        os.remove(root[6].attrib[""processing_time""])

+    if os.path.isfile(resume_root[4].attrib[""processing_time""]):

+        os.remove(resume_root[4].attrib[""processing_time""])

+    if os.path.isfile(resume_MPM_root[6].attrib[""processing_time""]):

+        os.remove(resume_MPM_root[6].attrib[""processing_time""])

+    if os.path.isfile(root[6].attrib[""homogenize_time""]):

+        os.remove(root[6].attrib[""homogenize_time""])

+    if root[6].attrib[""mode""] == ""11"":

+        pathlib.Path(root[6].attrib[""processing_time""]).touch()

+        pathlib.Path(resume_root[4].attrib[""processing_time""]).touch()

+        pathlib.Path(resume_MPM_root[6].attrib[""processing_time""]).touch()

+        pathlib.Path(root[6].attrib[""homogenize_time""]).touch()

+

+

+

 

 if __name__ == ""__main__"":

     main()
"
initSimulationEnv.py,False,,,True,initSimulationEnv.py,,,only_p2,,
interpolateMPMStress.py,True,interpolateMPMStress.py,,True,interpolateMPMStress.py,,False,diff,../output/diffs/interpolateMPMStress.py.diff,"--- /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/analysis/interpolateMPMStress.py
+++ /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/simulator/nagasu/interpolateMPMStress.py
@@ -1,14 +1,10 @@
 import numpy as np

-from OpenGL.GL import *

-from OpenGL.GLU import *

-from OpenGL.GLUT import *

-from PyQt5 import QtCore, QtGui, QtWidgets

-from PyQt5.QtOpenGL import *

 import math

 import copy

 from grainh5 import *

 from forceh5 import *

 from homogenizationh5 import *

+import ctypes

 class interpolateMPMStress:

     def __init__(self,  h, particle_data, grid_start):

         self.resolution = np.zeros(2, dtype=ctypes.c_int)
"
makeSleepFlag.py,False,,,True,makeSleepFlag.py,,,only_p2,,
makefinishflag.py,False,,,True,makefinishflag.py,,,only_p2,,
nagasu_loop.py,False,,,True,nagasu_loop.py,,,only_p2,,
particlehomogenizationh5.py,True,particlehomogenizationh5.py,,True,particlehomogenizationh5.py,,True,same,,
plotGrainsPosition.py,False,,,True,plotGrainsPosition.py,,,only_p2,,
plotParticleStress.py,True,plotParticleStress.py,,True,plotParticleStress.py,,True,same,,
progressh5.py,True,progressh5.py,,True,progressh5.py,,False,diff,../output/diffs/progressh5.py.diff,
qt_gl_widget2.py,True,qt_gl_widget2.py,,True,qt_gl_widget2.py,,False,diff,../output/diffs/qt_gl_widget2.py.diff,"--- /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/analysis/qt_gl_widget2.py
+++ /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/simulator/nagasu/qt_gl_widget2.py
@@ -207,7 +207,7 @@
         self.inner_height = h

 

     def initializeGL(self):

-        glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH)

+        #glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH)

         glEnable(GL_BLEND)

         glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)

         glClearColor(1.0, 1.0, 1.0, 1.0)
"
removeoutlier.py,True,removeoutlier.py,,True,removeoutlier.py,,False,diff,../output/diffs/removeoutlier.py.diff,"--- /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/analysis/removeoutlier.py
+++ /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/simulator/nagasu/removeoutlier.py
@@ -1,15 +1,10 @@
 #http://www.not-enough.org/abe/manual/program-aa08/pyqt1.html

-

-from OpenGL.GL import *

-from OpenGL.GLU import *

-from OpenGL.GLUT import *

-from PyQt5 import QtCore, QtGui, QtWidgets

-from PyQt5.QtOpenGL import *

 import math

 import copy

 from grainh5 import *

 from forceh5 import *

 from homogenizationh5 import *

+import ctypes

 

 class RemoveOutlier:

     def __init__(self):

@@ -31,16 +26,16 @@
     def calcPackingfraction(self, scene_data):

         #set packing fraction data

         N = np.prod(self.resolution)

-        packing_fraction = np.zeros(N,dtype=ctypes.c_float)

-        for e in scene_data.elements:

-            if e.static==True:

+        packing_fraction = np.zeros(N, dtype=ctypes.c_float)

+        for i in range(len(scene_data.all_step_elements_center_of_mass_array)):

+            if scene_data.all_step_elements_static_array[i]:

                 continue

-            cell_idx = np.floor((e.center_of_mass - self.grid_start) / self.h).astype(int)

+            cell_idx = np.floor((scene_data.all_step_elements_center_of_mass_array[i] - self.grid_start) / self.h).astype(int)

             flat_idx = cell_idx[1] * self.resolution[0] + cell_idx[0]

             if flat_idx >= N or flat_idx < 0:   #剛体の中心が格子の外にある

                 continue

-            e_template = scene_data.templates[e.template_name]

-            packing_fraction[flat_idx] += e.size_ratio * e.size_ratio * self.computeArea(e_template.vertex_list, e_template.size_mean)

+            e_template = scene_data.templates[scene_data.all_step_elements_template_idx_to_name_dict[scene_data.all_step_elements_template_idx_array[i]]]

+            packing_fraction[flat_idx] += scene_data.all_step_elements_size_ratio_array[i] * scene_data.all_step_elements_size_ratio_array[i] * self.computeArea(e_template.vertex_list, e_template.size_mean)

 

         cell_volume = self.h * self.h

         for j in range(self.resolution[1]):

@@ -51,7 +46,7 @@
 

     def calcdistancefromwall(self, left_wall_position, floor_wall_position):

         N = np.prod(self.resolution)

-        distance_from_wall = np.zeros(N,dtype=ctypes.c_float)

+        distance_from_wall = np.zeros(N, dtype=ctypes.c_float)

         for j in range(self.resolution[1]):

             for i in range(self.resolution[0]):

                 grid_center_p = self.grid_start + self.h * np.array([i+0.5, j+0.5])

@@ -68,30 +63,29 @@
         self.resolution = homogenization_data.homogenization[0].resolution

         self.h = homogenization_data.homogenization[0].h

         N = np.prod(self.resolution)

-        self.packing_fraction = np.zeros(N,dtype=ctypes.c_float)

-        self.distance_from_wall = np.zeros(N,dtype=ctypes.c_float)

-        left_wall_position=[2]

-        floor_wall_position=[2]

+        self.packing_fraction = np.zeros(N, dtype=ctypes.c_float)

+        self.distance_from_wall = np.zeros(N, dtype=ctypes.c_float)

+        left_wall_position = np.array([0.0, 0.0]).transpose()

+        floor_wall_position = np.array([0.0, 0.0]).transpose()

         left_wall_position[0] = None

         floor_wall_position[0] = None

+        #壁の中心座標を取り出す

 

-        #壁の中心座標を取り出す

-        for e in data.elements:

-            if e.template_name == ""left_wall"":

-                if  left_wall_position[0] == None:

-                        left_wall_position=e.center_of_mass

-                else:   print(""WARNING:exist two left wall. rewrite this code."")

-            if e.template_name == ""floor_circle"":

-                if floor_wall_position[0] ==None or floor_wall_position.all() ==e.center_of_mass.all():

-                    floor_wall_position = e.center_of_mass

-                else: print(""フロアの中心がずれています"")

+        for i in range(len(data.all_step_elements_center_of_mass_array)):

+            if data.all_step_elements_template_idx_to_name_dict[data.all_step_elements_template_idx_array[i]] == ""left_wall"":

+                left_wall_position[0] = math.fabs(data.templates[data.all_step_elements_template_idx_to_name_dict[data.all_step_elements_template_idx_array[i]]].vertex_list[0][1] + data.templates[data.all_step_elements_template_idx_to_name_dict[data.all_step_elements_template_idx_array[i]]].vertex_list[0][0])

+                

+            if data.all_step_elements_template_idx_to_name_dict[data.all_step_elements_template_idx_array[i]] == ""floor_circle"":

+                if floor_wall_position[0] == None or floor_wall_position.all() == data.all_step_elements_center_of_mass_array[i].all():

+                    floor_wall_position = data.all_step_elements_center_of_mass_array[i]

+                else:print(""フロアの中心がずれています"")

 

         #パッキング率を計算

         self.packing_fraction = self.calcPackingfraction(data)

         #グリッド中心から壁からの最短距離を求める

         self.distance_from_wall = self.calcdistancefromwall(left_wall_position, floor_wall_position)

 

-    

+

     def removeGrid(self, homogenization_data, packing_fraction_threshold, distance_from_wall_threshold):

         self.resolution = homogenization_data.homogenization[0].resolution

         for j in range(self.resolution[1]):
"
rewriteResumefn.py,True,rewriteResumefn.py,,True,rewriteResumefn.py,,False,diff,../output/diffs/rewriteResumefn.py.diff,"--- /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/analysis/rewriteResumefn.py
+++ /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/simulator/nagasu/rewriteResumefn.py
@@ -1,24 +1,16 @@
+import time

 import xml.etree.ElementTree as ET

 import sys

 import h5py

 import numpy as np

 import shutil

 

-

 def main():

     args = sys.argv

-

-    if len(args) < 2:

-        print('rewriteResumefn.py homogenize_stress.xml')

-        exit(1)

 

     homogenize_stress_fn = args[1]

     tree = ET.parse(homogenize_stress_fn)

     root = tree.getroot()

-

-    if root[2].tag != ""resume"":

-        print(""not resume line"")

-        exit(1)

 

     resume_xml_fn = root[2].attrib[""resume_fn""]

     interval = float(root[2].attrib[""interval""])

@@ -26,23 +18,11 @@
     resume_tree = ET.parse(resume_xml_fn)

     resume_root = resume_tree.getroot()

 

-    if resume_root[0].tag != ""integrator"":

-        print(""not integrator line"")

-        exit(1)

-

     current_max_time = float(resume_root[0].attrib[""max_time""])

     next_max_time = current_max_time + interval

 

     resume_root[0].attrib[""max_time""] = ""{:.6f}"".format(next_max_time)

     resume_tree.write(resume_xml_fn)

-

-    if root[0].tag != ""elements"":

-        print(""not resume line"")

-        exit(1)

-

-    if root[5].tag != ""rolling"":

-        print(""not rolling line"")

-        exit(1)

 

     forces_fn = root[0].attrib[""forces""]

     stress_pair_fn = root[1].attrib[""stress_pair""]

@@ -66,9 +46,9 @@
     if current_max_time < next_rolling_time:

         return

 

-    time = ""{:.6f}"".format(next_rolling_time)

-    rolling_elem_fn = base_elem_fn[:len(base_elem_fn) - 3] + ""_"" + time + base_elem_fn[len(base_elem_fn) - 3:]

-    rolling_stress_fn = base_stress_fn[:len(base_stress_fn) - 3] + ""_"" + time + base_stress_fn[len(base_stress_fn) - 3:]

+    t = ""{:.6f}"".format(next_rolling_time)

+    rolling_elem_fn = base_elem_fn[:len(base_elem_fn) - 3] + ""_"" + t + base_elem_fn[len(base_elem_fn) - 3:]

+    rolling_stress_fn = base_stress_fn[:len(base_stress_fn) - 3] + ""_"" + t + base_stress_fn[len(base_stress_fn) - 3:]

 

     shutil.copy2(base_elem_fn, rolling_elem_fn)

     shutil.copy2(stress_pair_fn, rolling_stress_fn)

@@ -77,5 +57,6 @@
     tree.write(homogenize_stress_fn)

 

 

+

 if __name__ == ""__main__"":

     main()
"
storeStressPair.py,True,storeStressPair.py,,True,storeStressPair.py,,False,diff,../output/diffs/storeStressPair.py.diff,"--- /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/analysis/storeStressPair.py
+++ /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/simulator/nagasu/storeStressPair.py
@@ -6,20 +6,15 @@
 import sys

 import os

 import ctypes

+import time

 

 

 def main():

     args = sys.argv

 

-    if len(args) < 2:

-        print('rewriteResumefn.py homogenize_stress_fn')

-

     resume_xml_fn = args[1]

     tree = ET.parse(resume_xml_fn)

     root = tree.getroot()

-

-    if root[1].tag != ""stress"":

-        print(""not resume line"")

 

     pre_fn = root[1].attrib[""pre_stress""]

     post_fn = root[1].attrib[""post_stress""]

@@ -64,6 +59,5 @@
 

         stress_pair_data.save(stress_pair_fn, all_pre_homogenization_data.all_timestep[i])

 

-

 if __name__ == ""__main__"":

     main()
"
stress_pair_compressor.py,True,stress_pair_compressor.py,,True,stress_pair_compressor.py,,False,diff,../output/diffs/stress_pair_compressor.py.diff,"--- /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/analysis/stress_pair_compressor.py
+++ /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/simulator/nagasu/stress_pair_compressor.py
@@ -4,6 +4,11 @@
 from stresspairh5 import *

 from tqdm import tqdm

 import ctypes

+from sklearn.linear_model import LinearRegression

+import sys

+from stress_plot_widget import *

+import scipy.stats as stats

+import cmath

 

 

 class StressPairEdit:

@@ -89,7 +94,8 @@
     def is_out_of_scope(pre_stress: ndarray, post_stress: ndarray) -> bool:

         lim = 250

 

-        if pre_stress[0] > 0 > pre_stress[1]:

+        #if pre_stress[0] > 0 > pre_stress[11]:

+        if pre_stress[0] > 0 or post_stress[0] > 0:

             return True

 

         if post_stress[0] > 0 > post_stress[1]:

@@ -133,6 +139,7 @@
         total_theta = 0.0

         total_count = 0

 

+        

         for path in tqdm(path_list):

             all_stress_pair_data.clear()

             all_stress_pair_data.pre_load(path)

@@ -172,7 +179,102 @@
 

         StressPairEdit.output_data(out_fn, ""total"", total_moving, total_rot90_moving, total_count,

                                    total_theta, total_dem_pos)

-

+        """"""

+

+        #回帰直線導出

+        lines = np.zeros((count, 2, 2), dtype=ctypes.c_float)

+        idx = 0

+        for key in tqdm(all_stress_pair_data.sorted_keys, leave=False):

+            stress_pair_data = StressPairData()

+            stress_pair_data.load(path, key)

+

+            for stress_pair in stress_pair_data.stress_pair_array:

+                pre_principal_stress, post_principal_stress = StressPairEdit.compute_principal_stress(stress_pair)

+

+                if StressPairEdit.is_out_of_scope(pre_principal_stress, post_principal_stress):

+                    continue

+                #lines[idx, 0] = np.array([pre_principal_stress[0], pre_principal_stress[11]])

+                lines[idx, 11] = np.array([post_principal_stress[0], post_principal_stress[11]])

+                idx = idx + 11

+

+        model_lr = LinearRegression(fit_intercept=False)

+        x = lines[:, 11, 0]

+        y = lines[:, 11, 11]

+        x = x.reshape(-11, 11)

+        y = y.reshape(-11, 11)

+        model_lr.fit(x, y)

+

+        print('モデル関数の回帰変数 w1: %.3f' % model_lr.coef_)

+        #print('モデル関数の切片 w2: %.3f' % model_lr.intercept_)

+        #print('y= %.3fx + %.3f' % (model_lr.coef_, model_lr.intercept_))

+        print('決定係数 R^2： ', model_lr.score(x, y))

+        

+

+        # 直線と点の角度の分散を算出

+        angles_point_from_origin = np.zeros(count, dtype=ctypes.c_float)

+        #mean_angle = math.atan2(model_lr.coef_, 11.0)

+        mean_angle = math.atan2(total_dem_pos[11] / total_count, total_dem_pos[0] / total_count)

+

+        total_circular_variance = 0.0

+        total_simple_variance = 0.0

+        idx = 0

+        current = 0

+        previous = 0

+        for key in tqdm(all_stress_pair_data.sorted_keys, leave=False):

+            stress_pair_data = StressPairData()

+            stress_pair_data.load(path, key)

+

+            for stress_pair in stress_pair_data.stress_pair_array:

+                pre_principal_stress, post_principal_stress = StressPairEdit.compute_principal_stress(stress_pair)

+

+                if StressPairEdit.is_out_of_scope(pre_principal_stress, post_principal_stress):

+                    continue

+

+                angles_point_from_origin[idx] = math.atan2(post_principal_stress[11], post_principal_stress[0])

+

+                total_simple_variance = total_simple_variance + pow(angles_point_from_origin[idx] - mean_angle, 2)

+                idx += 11

+

+                previous = current

+        #angles_complex = np.frompyfunc(cmath.exp, 11, 11)(angles_point_from_origin * 1j)

+        #total_circular_variance = abs(angles_complex.sum()) / idx

+

+        #print(""角度の分散(単位ベクトル合算法):"" + round(11 - total_circular_variance, 7))

+        print(""角度の分散（rad）:"", total_simple_variance / idx)

+        """"""

+

+        # 回帰直線からの残差、点との分散を算出

+

+        total_variance = 0.0

+        angles_point_from_origin = np.zeros(total_count, dtype=ctypes.c_float)

+        mean_angle = math.atan2(total_dem_pos[1] / total_count, total_dem_pos[0] / total_count)

+        idx = 0

+        current = 0

+        previous = 0

+        for key in tqdm(all_stress_pair_data.sorted_keys, leave=False):

+            stress_pair_data = StressPairData()

+            stress_pair_data.load(path, key)

+

+            for stress_pair in stress_pair_data.stress_pair_array:

+                pre_principal_stress, post_principal_stress = StressPairEdit.compute_principal_stress(stress_pair)

+

+                if StressPairEdit.is_out_of_scope(pre_principal_stress, post_principal_stress):

+                    continue

+                angles_point_from_origin[idx] = math.atan2(post_principal_stress[1], post_principal_stress[0])

+                total_simple_variance = total_simple_variance + pow(angles_point_from_origin[idx] - mean_angle, 2)

+

+                idx += 1

+

+                previous = current

+

+

+        print(""分散（点と直線の距離の分散）:"", total_simple_variance / idx)

+

+

+    def Calc_distance(self, a, b, c, point_x, point_y):  # 直線ax+by+c=0 点(x0,y0)

+        numer = abs(a * point_x + b * point_y + c)  # 分子

+        denom = math.sqrt(pow(a, 2) + pow(b, 2))  # 分母

+        return numer / denom  # 計算結果

 

 def main():

     mode = 1  # 0 = 応力圧縮, 11 = 応力解析

@@ -181,27 +283,47 @@
     # 応力圧縮

     if mode == 0:

         # 圧縮対象の応力データファイルへのパス

-        stress_fn = ""simulated_data/tri_high/stress_pair_0.500000.h5""

+        stress_fn = ""Output/stress_pair.h5""

 

         # 応力データに対応した粒子データファイルへのパス

-        scene_fn = ""simulated_data/tri_high/element_data_0.500000.h5""

+        scene_fn = ""Output/element_data.h5""

 

         # 圧縮後のファイル保存先

-        compressed_stress_fn = ""simulated_data/tri_high/compressed_stress.h5""

+        compressed_stress_fn = ""Output/compressed_stress.h5""

         

         stress_pair_edit.compress(stress_fn, scene_fn, compressed_stress_fn)

 

     # 応力解析

     if mode == 1:

         # 結果出力先

-        out_fn = ""debug/debug_square.txt""

         

         # データ解析対象ファイルを列挙

-        stress_fn = [""simulated_data/triangle/stress_pair_0.500000.h5"",

-                     ""simulated_data/tri_high/stress_pair_0.500000.h5""]

-

-        # stress_fn = [""simulated_data/21/compressed_stress.h5"",

-        #              ""simulated_data/11/compressed_stress.h5""]

+        #stress_fn = [""Output/compressed_stress.h5""]

+

+        if len(sys.argv) >= 1:

+            # stress_fn = [""IOData/"" + str(sys.argv[11]) + ""/11/compressed_stress.h5"",

+            #              ""IOData/"" + str(sys.argv[11]) + ""/12/compressed_stress.h5"",

+            #              ""IOData/"" + str(sys.argv[11]) + ""/13/compressed_stress.h5"",

+            #              ""IOData/"" + str(sys.argv[11]) + ""/21/compressed_stress.h5"",

+            #              ""IOData/"" + str(sys.argv[11]) + ""/31/compressed_stress.h5"",

+            #              ""IOData/"" + str(sys.argv[11]) + ""/22/compressed_stress.h5"",

+            #]

+            stress_fn = [""Save_"" + str(sys.argv[1]) + ""11_flow/stress_pair.h5"",

+                        ""Rolling_circle12_flow/stress_pair_1.000000.h5"",

+                         ""Save_"" + str(sys.argv[1]) + ""13_flow/stress_pair.h5"",

+                         ""Save_"" + str(sys.argv[1]) + ""21_flow/stress_pair.h5"",

+                         ""Save_"" + str(sys.argv[1]) + ""31_flow/stress_pair.h5"",

+                         ""Save_"" + str(sys.argv[1]) + ""22_flow/stress_pair.h5"",

+                        ]

+

+            #stress_fn = [""Rolling_circle12_flow/stress_pair_1.000000.h5""]

+

+        #debug

+        # if len(sys.argv) >= 11:

+        #     stress_fn = [""IOData/"" + str(sys.argv[11]) + ""/11/compressed_stress.h5""]

+

+

+            out_fn = ""debug/debug_"" + str(sys.argv[1]) + "".txt""

 

         with open(out_fn, mode='a') as f:

             f.write(""--------------------------------\n\n"")

@@ -211,3 +333,4 @@
 

 if __name__ == ""__main__"":

     main()

+
"
stress_pair_variance.py,False,,,True,stress_pair_variance.py,,,only_p2,,
stress_plot_widget.py,True,stress_plot_widget.py,,True,stress_plot_widget.py,,False,diff,../output/diffs/stress_plot_widget.py.diff,"--- /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/analysis/stress_plot_widget.py
+++ /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/simulator/nagasu/stress_plot_widget.py
@@ -19,10 +19,10 @@
 

 class StressPlotCanvas(FigureCanvas):

     def __init__(self, parent=None, width=5, height=4, dpi=100):

-        fig = Figure(figsize=(width, height), dpi=dpi)

-        self.axes = fig.add_subplot(1, 1, 1)

-

-        FigureCanvas.__init__(self, fig)

+        self.fig = Figure(figsize=(width, height), dpi=dpi)

+        self.axes = self.fig.add_subplot(1, 1, 1)

+

+        FigureCanvas.__init__(self, self.fig)

         self.setParent(parent)

 

         self.all_stress_pair_data = AllStressPairData()

@@ -43,6 +43,17 @@
 

         self.x_grad = 24.24894563

         self.y_grad = 0

+

+        self.x_shift = 0.0

+        self.y_shift = 0.0

+        self.zoom = 0.0

+

+        self.past_move_x = 0.0

+        self.past_move_y = 0.0

+        self.past_zoom = 1.0

+

+        self.shift_volume = 1000.0

+

 

     def calc_moving_average(self):

         count = 0

@@ -108,6 +119,38 @@
 

         self.set_axis()

         self.draw()

+

+    def set_move_plot_range_x(self, x_move):

+        self.x_shift = self.x_shift + x_move - self.past_move_x

+        self.past_move_x = x_move

+        self.axes.axis(

+            [(-self.current_lim + self.x_shift * self.shift_volume / self.current_lim),

+             (self.current_lim + self.x_shift * self.shift_volume / self.current_lim),

+             (-self.current_lim + self.y_shift * self.shift_volume / self.current_lim),

+             (self.current_lim + self.y_shift * self.shift_volume / self.current_lim)])

+        self.draw()

+

+    def set_move_plot_range_y(self, y_move):

+        self.y_shift = self.y_shift + y_move - self.past_move_y

+        self.past_move_y = y_move

+        self.axes.axis(

+            [(-self.current_lim + self.x_shift * self.shift_volume / self.current_lim),

+             (self.current_lim + self.x_shift * self.shift_volume / self.current_lim),

+             (-self.current_lim + self.y_shift * self.shift_volume / self.current_lim),

+             (self.current_lim + self.y_shift * self.shift_volume / self.current_lim)])

+        self.draw()

+

+    def set_zoom_plot(self, zoom):

+        self.current_lim = self.current_lim * zoom / self.past_zoom

+        self.past_zoom = zoom

+        self.axes.axis(

+            [(-self.current_lim + self.x_shift * self.shift_volume / self.current_lim),

+             (self.current_lim + self.x_shift * self.shift_volume / self.current_lim),

+             (-self.current_lim + self.y_shift * self.shift_volume / self.current_lim),

+             (self.current_lim + self.y_shift * self.shift_volume / self.current_lim)])

+

+        self.draw()

+

 

     @staticmethod

     def compute_principal_stress(stress_pair):

@@ -168,7 +211,11 @@
 

         self.axes.plot([0.0, -self.max_lim], [0.0, self.y(-self.max_lim)], color='m', linewidth=self.line_width)

 

-        self.axes.axis([-self.current_lim, self.current_lim, -self.current_lim, self.current_lim])

+        self.axes.axis(

+            [(-self.current_lim + self.x_shift * self.shift_volume / self.current_lim),

+             (self.current_lim + self.x_shift * self.shift_volume / self.current_lim),

+             (-self.current_lim + self.y_shift * self.shift_volume / self.current_lim),

+             (self.current_lim + self.y_shift * self.shift_volume / self.current_lim)])

         self.axes.grid()

 

     def replot(self):

@@ -210,11 +257,20 @@
         self.y_grad = y_grad

         self.stride = stride

         self.line_width = width

-        self.replot()

+        self.init_slider_parameter()

+        self.replot()

+

+    def init_slider_parameter(self):

+        self.x_shift = 0.0

+        self.y_shift = 0.0

+        self.past_move_x = 0.0

+        self.past_move_y = 0.0

+        self.past_zoom = 1.0

 

     def reset_current_lim(self):

         self.current_lim = self.max_lim

         self.replot()

+        self.init_slider_parameter()

 

     def set_cell_pos(self, cell_pos):

         self.cell_pos_list = cell_pos
"
stresspairh5.py,True,stresspairh5.py,,True,stresspairh5.py,,True,same,,
stressviewer.py,True,stressviewer.py,,True,stressviewer.py,,True,same,,
vertex_buffer_objects.py,True,vertex_buffer_objects.py,,True,vertex_buffer_objects.py,,True,same,,
