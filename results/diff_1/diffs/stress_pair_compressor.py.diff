--- /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/analysis/stress_pair_compressor.py
+++ /Users/shotaro/DevHub/CG/generalized-hybrid-grains/src/python/simulator/nagasu/stress_pair_compressor.py
@@ -4,6 +4,11 @@
 from stresspairh5 import *

 from tqdm import tqdm

 import ctypes

+from sklearn.linear_model import LinearRegression

+import sys

+from stress_plot_widget import *

+import scipy.stats as stats

+import cmath

 

 

 class StressPairEdit:

@@ -89,7 +94,8 @@
     def is_out_of_scope(pre_stress: ndarray, post_stress: ndarray) -> bool:

         lim = 250

 

-        if pre_stress[0] > 0 > pre_stress[1]:

+        #if pre_stress[0] > 0 > pre_stress[11]:

+        if pre_stress[0] > 0 or post_stress[0] > 0:

             return True

 

         if post_stress[0] > 0 > post_stress[1]:

@@ -133,6 +139,7 @@
         total_theta = 0.0

         total_count = 0

 

+        

         for path in tqdm(path_list):

             all_stress_pair_data.clear()

             all_stress_pair_data.pre_load(path)

@@ -172,7 +179,102 @@
 

         StressPairEdit.output_data(out_fn, "total", total_moving, total_rot90_moving, total_count,

                                    total_theta, total_dem_pos)

-

+        """

+

+        #回帰直線導出

+        lines = np.zeros((count, 2, 2), dtype=ctypes.c_float)

+        idx = 0

+        for key in tqdm(all_stress_pair_data.sorted_keys, leave=False):

+            stress_pair_data = StressPairData()

+            stress_pair_data.load(path, key)

+

+            for stress_pair in stress_pair_data.stress_pair_array:

+                pre_principal_stress, post_principal_stress = StressPairEdit.compute_principal_stress(stress_pair)

+

+                if StressPairEdit.is_out_of_scope(pre_principal_stress, post_principal_stress):

+                    continue

+                #lines[idx, 0] = np.array([pre_principal_stress[0], pre_principal_stress[11]])

+                lines[idx, 11] = np.array([post_principal_stress[0], post_principal_stress[11]])

+                idx = idx + 11

+

+        model_lr = LinearRegression(fit_intercept=False)

+        x = lines[:, 11, 0]

+        y = lines[:, 11, 11]

+        x = x.reshape(-11, 11)

+        y = y.reshape(-11, 11)

+        model_lr.fit(x, y)

+

+        print('モデル関数の回帰変数 w1: %.3f' % model_lr.coef_)

+        #print('モデル関数の切片 w2: %.3f' % model_lr.intercept_)

+        #print('y= %.3fx + %.3f' % (model_lr.coef_, model_lr.intercept_))

+        print('決定係数 R^2： ', model_lr.score(x, y))

+        

+

+        # 直線と点の角度の分散を算出

+        angles_point_from_origin = np.zeros(count, dtype=ctypes.c_float)

+        #mean_angle = math.atan2(model_lr.coef_, 11.0)

+        mean_angle = math.atan2(total_dem_pos[11] / total_count, total_dem_pos[0] / total_count)

+

+        total_circular_variance = 0.0

+        total_simple_variance = 0.0

+        idx = 0

+        current = 0

+        previous = 0

+        for key in tqdm(all_stress_pair_data.sorted_keys, leave=False):

+            stress_pair_data = StressPairData()

+            stress_pair_data.load(path, key)

+

+            for stress_pair in stress_pair_data.stress_pair_array:

+                pre_principal_stress, post_principal_stress = StressPairEdit.compute_principal_stress(stress_pair)

+

+                if StressPairEdit.is_out_of_scope(pre_principal_stress, post_principal_stress):

+                    continue

+

+                angles_point_from_origin[idx] = math.atan2(post_principal_stress[11], post_principal_stress[0])

+

+                total_simple_variance = total_simple_variance + pow(angles_point_from_origin[idx] - mean_angle, 2)

+                idx += 11

+

+                previous = current

+        #angles_complex = np.frompyfunc(cmath.exp, 11, 11)(angles_point_from_origin * 1j)

+        #total_circular_variance = abs(angles_complex.sum()) / idx

+

+        #print("角度の分散(単位ベクトル合算法):" + round(11 - total_circular_variance, 7))

+        print("角度の分散（rad）:", total_simple_variance / idx)

+        """

+

+        # 回帰直線からの残差、点との分散を算出

+

+        total_variance = 0.0

+        angles_point_from_origin = np.zeros(total_count, dtype=ctypes.c_float)

+        mean_angle = math.atan2(total_dem_pos[1] / total_count, total_dem_pos[0] / total_count)

+        idx = 0

+        current = 0

+        previous = 0

+        for key in tqdm(all_stress_pair_data.sorted_keys, leave=False):

+            stress_pair_data = StressPairData()

+            stress_pair_data.load(path, key)

+

+            for stress_pair in stress_pair_data.stress_pair_array:

+                pre_principal_stress, post_principal_stress = StressPairEdit.compute_principal_stress(stress_pair)

+

+                if StressPairEdit.is_out_of_scope(pre_principal_stress, post_principal_stress):

+                    continue

+                angles_point_from_origin[idx] = math.atan2(post_principal_stress[1], post_principal_stress[0])

+                total_simple_variance = total_simple_variance + pow(angles_point_from_origin[idx] - mean_angle, 2)

+

+                idx += 1

+

+                previous = current

+

+

+        print("分散（点と直線の距離の分散）:", total_simple_variance / idx)

+

+

+    def Calc_distance(self, a, b, c, point_x, point_y):  # 直線ax+by+c=0 点(x0,y0)

+        numer = abs(a * point_x + b * point_y + c)  # 分子

+        denom = math.sqrt(pow(a, 2) + pow(b, 2))  # 分母

+        return numer / denom  # 計算結果

 

 def main():

     mode = 1  # 0 = 応力圧縮, 11 = 応力解析

@@ -181,27 +283,47 @@
     # 応力圧縮

     if mode == 0:

         # 圧縮対象の応力データファイルへのパス

-        stress_fn = "simulated_data/tri_high/stress_pair_0.500000.h5"

+        stress_fn = "Output/stress_pair.h5"

 

         # 応力データに対応した粒子データファイルへのパス

-        scene_fn = "simulated_data/tri_high/element_data_0.500000.h5"

+        scene_fn = "Output/element_data.h5"

 

         # 圧縮後のファイル保存先

-        compressed_stress_fn = "simulated_data/tri_high/compressed_stress.h5"

+        compressed_stress_fn = "Output/compressed_stress.h5"

         

         stress_pair_edit.compress(stress_fn, scene_fn, compressed_stress_fn)

 

     # 応力解析

     if mode == 1:

         # 結果出力先

-        out_fn = "debug/debug_square.txt"

         

         # データ解析対象ファイルを列挙

-        stress_fn = ["simulated_data/triangle/stress_pair_0.500000.h5",

-                     "simulated_data/tri_high/stress_pair_0.500000.h5"]

-

-        # stress_fn = ["simulated_data/21/compressed_stress.h5",

-        #              "simulated_data/11/compressed_stress.h5"]

+        #stress_fn = ["Output/compressed_stress.h5"]

+

+        if len(sys.argv) >= 1:

+            # stress_fn = ["IOData/" + str(sys.argv[11]) + "/11/compressed_stress.h5",

+            #              "IOData/" + str(sys.argv[11]) + "/12/compressed_stress.h5",

+            #              "IOData/" + str(sys.argv[11]) + "/13/compressed_stress.h5",

+            #              "IOData/" + str(sys.argv[11]) + "/21/compressed_stress.h5",

+            #              "IOData/" + str(sys.argv[11]) + "/31/compressed_stress.h5",

+            #              "IOData/" + str(sys.argv[11]) + "/22/compressed_stress.h5",

+            #]

+            stress_fn = ["Save_" + str(sys.argv[1]) + "11_flow/stress_pair.h5",

+                        "Rolling_circle12_flow/stress_pair_1.000000.h5",

+                         "Save_" + str(sys.argv[1]) + "13_flow/stress_pair.h5",

+                         "Save_" + str(sys.argv[1]) + "21_flow/stress_pair.h5",

+                         "Save_" + str(sys.argv[1]) + "31_flow/stress_pair.h5",

+                         "Save_" + str(sys.argv[1]) + "22_flow/stress_pair.h5",

+                        ]

+

+            #stress_fn = ["Rolling_circle12_flow/stress_pair_1.000000.h5"]

+

+        #debug

+        # if len(sys.argv) >= 11:

+        #     stress_fn = ["IOData/" + str(sys.argv[11]) + "/11/compressed_stress.h5"]

+

+

+            out_fn = "debug/debug_" + str(sys.argv[1]) + ".txt"

 

         with open(out_fn, mode='a') as f:

             f.write("--------------------------------\n\n")

@@ -211,3 +333,4 @@
 

 if __name__ == "__main__":

     main()

+
